name: Resolve Workspace Dependencies
description: Analyze workspace dependencies and return packages in publishing order

inputs:
  packages:
    description: "Comma-separated list of package names to analyze"
    required: true

outputs:
  packages:
    description: "Comma-separated list of packages in dependency order"
    value: ${{ steps.resolve.outputs.packages }}

runs:
  using: composite
  steps:
    - name: Resolve dependency order
      id: resolve
      shell: bash
      run: |
        # Parse input packages
        IFS=',' read -ra PACKAGE_ARRAY <<< "${{ inputs.packages }}"

        # If only one package, return it directly
        if [ ${#PACKAGE_ARRAY[@]} -eq 1 ]; then
          echo "packages=${{ inputs.packages }}" >> "$GITHUB_OUTPUT"
          echo "üì¶ Single package, no dependency resolution needed"
          exit 0
        fi

        echo "üîç Analyzing workspace dependencies for: ${{ inputs.packages }}"

        # Build dependency graph
        declare -A depends_on=()  # package -> list of packages it depends on
        declare -A depended_by=() # package -> list of packages that depend on it

        for package in "${PACKAGE_ARRAY[@]}"; do
          depends_on[$package]=""
          depended_by[$package]=""

          if [ -f "packages/$package/package.json" ]; then
            # Check dependencies, devDependencies, and peerDependencies for workspace refs
            workspace_deps=$(jq -r '
              (.dependencies // {}) as $deps |
              (.devDependencies // {}) as $devDeps |
              (.peerDependencies // {}) as $peerDeps |
              (
                $deps | to_entries[] | select(.value | contains("workspace:")) | .key
              ),
              (
                $devDeps | to_entries[] | select(.value | contains("workspace:")) | .key
              ),
              (
                $peerDeps | to_entries[] | select(.value | contains("workspace:")) | .key
              )
            ' "packages/$package/package.json" 2>/dev/null)

            # Filter to only include packages in our list
            for dep in $workspace_deps; do
              for candidate in "${PACKAGE_ARRAY[@]}"; do
                if [ "$dep" = "$candidate" ]; then
                  # $package depends on $candidate
                  depends_on[$package]="${depends_on[$package]:+${depends_on[$package]},}$candidate"
                  depended_by[$candidate]="${depended_by[$candidate]:+${depended_by[$candidate]},}$package"
                  break
                fi
              done
            done
          fi
        done

        # Debug output
        echo "üìã Dependency analysis:"
        for package in "${PACKAGE_ARRAY[@]}"; do
          echo "  $package depends on: ${depends_on[$package]:-none}"
          echo "  $package is depended on by: ${depended_by[$package]:-none}"
        done

        # Topological sort to get publishing order (dependencies first)
        # States: 0=not visited, 1=visiting, 2=visited
        declare -A state=()

        # Initialize states
        for package in "${PACKAGE_ARRAY[@]}"; do
          state[$package]=0
        done

        declare -a result=()
        declare -a cycle_detected=false

        function visit() {
          local package="$1"

          # If already visited, skip
          if [ "${state[$package]}" -eq 2 ]; then
            return
          fi

          # If currently visiting (in recursion stack), we have a cycle!
          if [ "${state[$package]}" -eq 1 ]; then
            echo "‚ùå Cycle detected involving package: $package"
            cycle_detected=true
            return
          fi

          # Mark as currently visiting
          state[$package]=1

          # Visit all packages that depend on this one first
          # (they need to be published after this package)
          IFS=',' read -ra deps <<< "${depended_by[$package]}"
          for dep in "${deps[@]}"; do
            if [ -n "$dep" ]; then
              visit "$dep"
            fi
          done

          # Mark as fully visited and add to result
          state[$package]=2
          result=("$package" "${result[@]}")
        }

        # Visit all packages
        for package in "${PACKAGE_ARRAY[@]}"; do
          if [ "${state[$package]}" -eq 0 ]; then
            visit "$package"
          fi
        done

        # Check for cycles
        if [ "$cycle_detected" = true ]; then
          echo "‚ùå Cannot resolve publishing order due to circular dependencies"
          echo "packages=" >> "$GITHUB_OUTPUT"
          exit 1
        fi

        # Verify all packages were processed
        unprocessed=""
        for package in "${PACKAGE_ARRAY[@]}"; do
          if [ "${state[$package]}" -ne 2 ]; then
            unprocessed="${unprocessed:+$unprocessed,}$package"
          fi
        done

        if [ -n "$unprocessed" ]; then
          echo "‚ùå Some packages were not processed: $unprocessed"
          echo "packages=" >> "$GITHUB_OUTPUT"
          exit 1
        fi

        # Convert result array to comma-separated string
        ordered_packages=""
        for package in "${result[@]}"; do
          ordered_packages="${ordered_packages:+$ordered_packages,}$package"
        done

        echo "üì¶ Publishing order: $ordered_packages"
        echo "packages=$ordered_packages" >> "$GITHUB_OUTPUT"
